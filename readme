一个简单的Python制Scheme实现，施工中

* TODO
更多的测试代码
尾递归（在Py中模拟）
合并eval代码

* 说明
坑
 
* Changelog
** Nov.25
第一个版本，可以定义阶乘（递归）函数然后计算，一般的表达式计算也。
用正则模拟lex，手写的递归下降解析器，read函数，以及基本的eval。
可define可lambda，可用Python或Scheme来预定义环境。
** Nov.27
实现内部宏，方便扩充语法了，跑了一个计算24的代码，很慢很花内存。
现在的预定义的函数是用到一个就加进去一个，已经工作很良好了。
** Nov.28
单独实现了初步支持call/cc的eval版本，之后建立导出的API的时候再来合并代码吧。
如果call/cc支持多返回值的话，又得重实现一个eval了，虽然代码可照搬。

* TODO2
 + 只做TODO1里面的事情
** 优先级不高的TODO
 + 和Py的混合使用
 + 定义导出的API
 + 合并相同功能的不同实现
** 优先级更不高的TOGO
 + 性能啊
 + 整理代码
 + quote宏
 + 内部marco
 + 词法和句法中的'#'
** 不想添加的功能
 + 所有'!'结尾的过程
 + io相关的过程
 + 交互中提供eval过程
 + 交互中提供macro相关

** 代码风格
 + 不必要遵守以下代码风格
 + 能暂时不实现的功能就不去实现它，能推迟的改动尽量推迟
 + 当功能有眼前看得见的好处的时候才去实现它，比如实现另一个功能用到
 + 优先考虑实现新的功能，即使重也是整理新版本出来，切勿做出多余的事情来
 + 多写单元测试，特别是实现新功能的时候，测试过只做修补和添加分派
 + 有大的改动时，重写新的版本的函数，不改变已写代码的命名和行为习惯
 + 不看注释也要很容易看明白代码，通过细分函数的功能约束副作用以及测试代码
 + 一个过程限制在最小的功能，额外的扩产可以写一个以来它的新过程
 + 导出的API可以以后修改，旧的实现在有更新时可以重构到新的实现上
 + 优先考虑写在代码开头的说明文件

* 链接
 + SICP
 + IEEE
 + R5RS
 + tinyscheme
 + scm/slb
 + biwascheme
 + pyscheme